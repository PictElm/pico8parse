<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Luaparse</title>
    <link href="https://netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/css/bootstrap-combined.no-icons.min.css" rel="stylesheet">
    <style>
      .hero-unit .nav-pills a {
        font-size: 70%;
        color: #797979;
        margin-top: 4px;
      }
      .hero-unit .nav-pills a:hover {
        text-decoration: underline;
      }
      h2, h3, h4 { margin-top: 1em; }
    </style>
  </head>
  <body>
    <div class="hero-unit">
      <div class="container">
        <div class="row">
          <div class="span6">
            <h1>Pico8parse</h1>
            <p>A Lua parser written in JavaScript, with support for the PICO-8 flavour.<br/>Luaparse is originally written by Oskar Schöldström for his bachelor's thesis at Arcada.</p>
          </div>
          <div class="span6" style="padding-top: 35px;">
            <div class="btn-group">
              <a class="btn" href="https://github.com/PictElm/pico8parse">GitHub</a>
              <a class="btn" href="https://github.com/fstirlitz/luaparse">Original Project</a>
              <a class="btn" href="test/index.html">Tests</a>
            </div>
            <ul class="nav nav-pills">
              <li><a href="index.html">Home</a></li>
              <li><a href="upstream.html">About upstream</a></li>
              <li><a href="fork.html">About this fork</a></li>
              <li><a href="coverage.html">Coverage</a></li>
              <li><a href="examples.html">Examples</a></li>
            </ul>
          </div>
        </div>
      </div>
    </div>
    <div class="container">
<h1 id="luaparse">luaparse</h1>
<p>A Lua parser written in JavaScript, originally written by Oskar Schöldström for his bachelor&#39;s thesis at Arcada.</p>
<h2 id="installation">Installation</h2>
<p>Install through <code>npm install luaparse</code>.</p>
<h2 id="usage">Usage</h2>
<p>CommonJS</p>
<pre><code class="language-js">var parser = require(&#39;luaparse&#39;);
var ast = parser.parse(&#39;i = 0&#39;);
console.log(JSON.stringify(ast));</code></pre>
<p>AMD</p>
<pre><code class="language-js">require([&#39;luaparse&#39;], function(parser) {
  var ast = parser.parse(&#39;i = 0&#39;);
  console.log(JSON.stringify(ast));
});</code></pre>
<p>Browser</p>
<pre><code class="language-html">&lt;script src=&quot;luaparse.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
var ast = luaparse.parse(&#39;i = 0&#39;);
console.log(JSON.stringify(ast));
&lt;/script&gt;</code></pre>
<h2 id="parser-interface">Parser Interface</h2>
<p>Basic usage:</p>
<pre><code class="language-js">luaparse.parse(code, options);</code></pre>
<p>The output of the parser is an Abstract Syntax Tree (AST) formatted in JSON.</p>
<p>The available options are:</p>
<ul>
<li><code>wait: false</code> Explicitly tell the parser when the input ends.</li>
<li><code>comments: true</code> Store comments as an array in the chunk object.</li>
<li><code>scope: false</code> Track identifier scopes.</li>
<li><code>locations: false</code> Store location information on each syntax node.</li>
<li><code>ranges: false</code> Store the start and end character locations on each syntax
node.</li>
<li><code>onCreateNode: null</code> A callback which will be invoked when a syntax node
has been completed. The node which has been created will be passed as the
only parameter.</li>
<li><code>onCreateScope: null</code> A callback which will be invoked when a new scope is
created.</li>
<li><code>onDestroyScope: null</code> A callback which will be invoked when the current
scope is destroyed.</li>
<li><code>onLocalDeclaration: null</code> A callback which will be invoked when a local
variable is declared. The identifier will be passed as the only parameter.</li>
<li><code>luaVersion: &#39;5.1&#39;</code> The version of Lua the parser will target; supported
values are <code>&#39;5.1&#39;</code>, <code>&#39;5.2&#39;</code>, <code>&#39;5.3&#39;</code> and <code>&#39;LuaJIT&#39;</code>.</li>
<li><code>extendedIdentifiers: false</code> Whether to allow code points ≥ U+0080 in
identifiers, like LuaJIT does. <strong>Note:</strong> setting <code>luaVersion: &#39;LuaJIT&#39;</code>
currently does <em>not</em> enable this option; this may change in the future.</li>
<li><code>encodingMode: &#39;none&#39;</code> Defines the relation between code points ≥ U+0080
appearing in parser input and raw bytes in source code, and how Lua escape
sequences in JavaScript strings should be interpreted. See the
<a href="#encoding-modes">Encoding modes</a> section below for more information.</li>
</ul>
<p>The default options are also exposed through <code>luaparse.defaultOptions</code> where
they can be overriden globally.</p>
<p>There is a second interface which might be preferable when using the <code>wait</code>
option.</p>
<pre><code class="language-js">var parser = luaparse.parse({ wait: true });
parser.write(&#39;foo = &quot;&#39;);
parser.write(&#39;bar&#39;);
var ast = parser.end(&#39;&quot;&#39;);</code></pre>
<p>This would be identical to:</p>
<pre><code class="language-js">var ast = luaparse.parse(&#39;foo = &quot;bar&quot;&#39;);</code></pre>
<h3 id="ast-format">AST format</h3>
<p>If the following code is executed:</p>
<pre><code class="language-js">luaparse.parse(&#39;foo = &quot;bar&quot;&#39;);</code></pre>
<p>then the returned value will be:</p>
<pre><code class="language-js">{
  &quot;type&quot;: &quot;Chunk&quot;,
  &quot;body&quot;: [
    {
      &quot;type&quot;: &quot;AssignmentStatement&quot;,
      &quot;variables&quot;: [
        {
          &quot;type&quot;: &quot;Identifier&quot;,
          &quot;name&quot;: &quot;foo&quot;
        }
      ],
      &quot;init&quot;: [
        {
          &quot;type&quot;: &quot;StringLiteral&quot;,
          &quot;value&quot;: &quot;bar&quot;,
          &quot;raw&quot;: &quot;\&quot;bar\&quot;&quot;
        }
      ]
    }
  ],
  &quot;comments&quot;: []
}</code></pre>
<h3 id="encoding-modes">Encoding modes</h3>
<p>Unlike strings in JavaScript, Lua strings are not Unicode strings, but
bytestrings (sequences of 8-bit values); likewise, implementations of Lua
parse the source code as a sequence of octets. However, the input to this
parser is a JavaScript string, i.e. a sequence of 16-bit code units (not
necessarily well-formed UTF-16). This poses a problem of how those code
units should be interpreted, particularly if they are outside the Basic
Latin block (&#39;ASCII&#39;).</p>
<p>The <code>encodingMode</code> option specifies how these issues should be handled.
Possible values are as follows:</p>
<ul>
<li><code>&#39;none&#39;</code>: Source code characters all pass through as-is and string
literals are not interpreted at all; the string literal nodes contain
the value <code>null</code>. This is the default mode.</li>
<li><code>&#39;x-user-defined&#39;</code>: Source code has been decoded with the WHATWG
<code>x-user-defined</code> encoding; escapes of bytes in the range [0x80, 0xff]
are mapped to the Unicode range [U+F780, U+F7FF].</li>
<li><code>&#39;pseudo-latin1&#39;</code>: Source code has been decoded with the IANA
<code>iso-8859-1</code> encoding; escapes of bytes in the range [0x80, 0xff]
are mapped to Unicode range [U+0080, U+00FF]. Note that this is
<strong>not</strong> the same as how WHATWG standards define the <code>iso-8859-1</code>
encoding, which is to say, as a synonym of <code>windows-1252</code>.</li>
</ul>
<h3 id="custom-ast">Custom AST</h3>
<p>The default AST structure is somewhat inspired by the Mozilla Parser API but
can easily be overriden to customize the structure or to inject custom logic.</p>
<p><code>luaparse.ast</code> is an object containing all functions used to create the AST, if
you for example wanted to trigger an event on node creations you could use the
following:</p>
<pre><code class="language-js">var luaparse = require(&#39;luaparse&#39;),
    events = new (require(&#39;events&#39;).EventEmitter);

Object.keys(luaparse.ast).forEach(function(type) {
  var original = luaparse.ast[type];
  luaparse.ast[type] = function() {
    var node = original.apply(null, arguments);
    events.emit(node.type, node);
    return node;
  };
});
events.on(&#39;Identifier&#39;, function(node) { console.log(node); });
luaparse.parse(&#39;i = &quot;foo&quot;&#39;);</code></pre>
<p><em>this is only an example to illustrate what is possible and this particular
example might not suit your needs as the end location of the node has not been
determined yet. If you desire events you should use the <code>onCreateNode</code> callback
instead).</em></p>
<h3 id="lexer">Lexer</h3>
<p>The lexer used by luaparse can be used independently of the recursive descent
parser. The lex function is exposed as <code>luaparse.lex()</code> and it will return the
next token up until <code>EOF</code> is reached.</p>
<p>Each token consists of:</p>
<ul>
<li><code>type</code> expressed as an enum flag which can be matched with <code>luaparse.tokenTypes</code>.</li>
<li><code>value</code></li>
<li><code>line</code>, <code>lineStart</code></li>
<li><code>range</code> can be used to slice out raw values, eg. <code>foo = &quot;bar&quot;</code> will return a
<code>StringLiteral</code> token with the value <code>bar</code>. Slicing out the range on the other
hand will return <code>&quot;bar&quot;</code>.</li>
</ul>
<pre><code class="language-js">var parser = luaparse.parse(&#39;foo = &quot;bar&quot;&#39;, { wait: true });
parser.lex(); // { type: 8, value: &quot;foo&quot;, line: 1, lineStart: 0, range: [0, 3] }
parser.lex(); // { type: 32, value: &quot;=&quot;, line: 1, lineStart: 0, range: [4, 5]}
parser.lex(); // { type: 2, value: &quot;bar&quot;, line: 1, lineStart: 0, range: [6, 11] }
parser.lex(); // { type: 1, value: &quot;&lt;eof&gt;&quot;, line: 1, lineStart: 0, range: [11 11] }
parser.lex(); // { type: 1, value: &quot;&lt;eof&gt;&quot;, line: 1, lineStart: 0, range: [11 11] }</code></pre>
<h2 id="examples">Examples</h2>
<p>Have a look in the <a href="https://github.com/fstirlitz/luaparse/tree/master/examples">examples directory</a>
of the repository for some code examples or check them out <a href="https://fstirlitz.github.io/luaparse/examples.html">live</a>.</p>
<h2 id="luaparse1">luaparse(1)</h2>
<p>The <code>luaparse</code> executable can be used in your shell by installing <code>luaparse</code> globally using npm:</p>
<pre><code class="language-bash">$ npm install -g luaparse
$ luaparse --help

Usage: luaparse [option]... [file|code]...

Options:
  -c|--code [code]   parse code snippet
  -f|--file [file]   parse from file
  -b|--beautify      output an indenteted AST
  --[no]-comments    store comments. defaults to true
  --[no]-scope       store variable scope. defaults to false
  --[no]-locations   store location data on syntax nodes. defaults to false
  --[no]-ranges      store start and end character locations. defaults to false
  -q|--quiet         suppress output
  -h|--help
  -v|--version
  --verbose

Examples:
  luaparse --no-comments -c &quot;locale foo = \&quot;bar\&quot;&quot;
  luaparse foo.lua bar.lua</code></pre>
<p>Example usage</p>
<pre><code class="language-bash">$ luaparse &quot;i = 0&quot;

{&quot;type&quot;:&quot;Chunk&quot;,&quot;body&quot;:[{&quot;type&quot;:&quot;AssignmentStatement&quot;,&quot;variables&quot;:[{&quot;type&quot;:&quot;Identifier&quot;,&quot;name&quot;:&quot;i&quot;}],&quot;init&quot;:[{&quot;type&quot;:&quot;NumericLiteral&quot;,&quot;value&quot;:0,&quot;raw&quot;:&quot;0&quot;}]}],&quot;comments&quot;:[]}</code></pre>
<h2 id="support">Support</h2>
<p>Has been tested in at least IE6+, Firefox 3+, Safari 4+, Chrome 10+, Opera 10+,
Node 0.4.0+, RingoJS 0.8-0.9, Rhino 1.7R4-1.7R5, Nashorn 1.8.0.</p>
<h2 id="quality-assurance">Quality Assurance</h2>
<p><em>TL;DR simply run <code>make qa</code>. This will run all quality assurance scripts but
assumes you have it set up correctly.</em></p>
<p>Begin by cloning the repository and installing the development dependencies
with <code>npm install</code>.</p>
<p>The luaparse test suite uses <a href="https://github.com/airportyh/testem">testem</a> as a
test runner, and because of this it&#39;s very easy to run the tests using
different javascript engines or even on locally installed browsers.</p>
<h3 id="test-runners">Test runners</h3>
<ul>
<li><code>make test</code> uses node.</li>
<li><code>make testem-engines</code> uses node, ringo and rhino</li>
</ul>
<p>1.7R5. This requires that you have the engines installed.</p>
<ul>
<li><code>make test-node</code> uses a custom command line reporter to make the output
easier on the eyes while practicing TDD.</li>
<li>By installing <code>testem</code> globally you can also run the tests in a locally
installed browser.</li>
</ul>
<h3 id="other-quality-assurance-measures">Other quality assurance measures</h3>
<ul>
<li>You can check the function complexity using <a href="https://github.com/philbooth/complexityReport.js">complexity-report</a>
using <code>make complexity-analysis</code></li>
<li>Running <code>make coverage</code> will generate the <a href="https://fstirlitz.github.io/luaparse/coverage.html">coverage report</a>.
To simply check that all code has coverage you can run <code>make coverage-analysis</code>.</li>
<li><code>make lint</code>, <code>make benchmark</code>, <code>make profile</code>.</li>
</ul>
<h3 id="documentation">Documentation</h3>
<p>By running <code>make docs</code> all <a href="https://fstirlitz.github.io/luaparse/">documentation</a>
will be generated.</p>
<h2 id="projects-usingextending-luaparse">Projects using/extending luaparse</h2>
<ul>
<li><a href="http://mths.be/luamin">luamin</a>, a Lua minifier written by Mathias Bynens.</li>
<li><a href="https://github.com/ajaxorg/ace">Ace</a>, an online code editor.</li>
</ul>
<h2 id="acknowledgements">Acknowledgements</h2>
<ul>
<li>Initial tests are scaffolded from <a href="http://yueliang.luaforge.net/">yueliang</a> and then manually checked for error.</li>
<li>Much of the code is based on <a href="https://github.com/stravant/LuaMinify">LuaMinify</a>, the <a href="https://www.lua.org">Lua</a> source and <a href="http://esprima.org">Esprima</a>. All awesome projects.</li>
</ul>
<h2 id="license">License</h2>
<p>MIT</p>

    </div>
    <script>
      var _gaq = [['_setAccount', 'UA-6980403-7'], ['_trackPageview']];
      (function(d, t) {
        var g = d.createElement(t),
            s = d.getElementsByTagName(t)[0];
        g.src = '//www.google-analytics.com/ga.js';
        s.parentNode.insertBefore(g, s);
      }(this.document, 'script'));
    </script>
  </body>
</html>
